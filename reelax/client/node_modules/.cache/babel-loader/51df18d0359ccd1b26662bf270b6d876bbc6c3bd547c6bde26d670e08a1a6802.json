{"ast":null,"code":"/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, { PassThrough } from 'node:stream';\nimport { types, deprecate, promisify } from 'node:util';\nimport { Buffer } from 'node:buffer';\nimport Blob from 'fetch-blob';\nimport { FormData, formDataToBlob } from 'formdata-polyfill/esm.min.js';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { isBlob, isURLSearchParameters } from './utils/is.js';\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n  constructor(body) {\n    let {\n      size = 0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let boundary = null;\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {\n      // Body is blob\n    } else if (Buffer.isBuffer(body)) {\n      // Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {\n      // Body is stream\n    } else if (body instanceof FormData) {\n      // Body is FormData\n      body = formDataToBlob(body);\n      boundary = body.type.split('=')[1];\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n    let stream = body;\n    if (Buffer.isBuffer(body)) {\n      stream = Stream.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = Stream.Readable.from(body.stream());\n    }\n    this[INTERNALS] = {\n      body,\n      stream,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n  get body() {\n    return this[INTERNALS].stream;\n  }\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  async arrayBuffer() {\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n  async formData() {\n    const ct = this.headers.get('content-type');\n    if (ct.startsWith('application/x-www-form-urlencoded')) {\n      const formData = new FormData();\n      const parameters = new URLSearchParams(await this.text());\n      for (const [name, value] of parameters) {\n        formData.append(name, value);\n      }\n      return formData;\n    }\n    const {\n      toFormData\n    } = await import('./utils/multipart-parser.js');\n    return toFormData(this.body, ct);\n  }\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  async blob() {\n    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n    const buf = await this.arrayBuffer();\n    return new Blob([buf], {\n      type: ct\n    });\n  }\n\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  async text() {\n    const buffer = await consumeBody(this);\n    return new TextDecoder().decode(buffer);\n  }\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer() {\n    return consumeBody(this);\n  }\n}\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  },\n  data: {\n    get: deprecate(() => {}, 'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')\n  }\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n  data[INTERNALS].disturbed = true;\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n  const {\n    body\n  } = data;\n\n  // Body is null\n  if (body === null) {\n    return Buffer.alloc(0);\n  }\n\n  /* c8 ignore next 3 */\n  if (!(body instanceof Stream)) {\n    return Buffer.alloc(0);\n  }\n\n  // Body is stream\n  // get ready to actually consume the body\n  const accum = [];\n  let accumBytes = 0;\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n        body.destroy(error);\n        throw error;\n      }\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n    throw error_;\n  }\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every(c => typeof c === 'string')) {\n        return Buffer.from(accum.join(''));\n      }\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance[INTERNALS];\n\n  // Don't allow cloning a used body\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  }\n\n  // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2);\n    // Set instance body to teed body and return the other teed body\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n  return body;\n};\nconst getNonSpecFormDataBoundary = deprecate(body => body.getBoundary(), 'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  }\n\n  // Body is string\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  }\n\n  // Body is a URLSearchParams\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  }\n\n  // Body is blob\n  if (isBlob(body)) {\n    return body.type || null;\n  }\n\n  // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n  if (body instanceof FormData) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  }\n\n  // Detect form data input from form-data module\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n  }\n\n  // Body is stream - can't really do much about this\n  if (body instanceof Stream) {\n    return null;\n  }\n\n  // Body constructor defaults other things to string\n  return 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request[INTERNALS];\n\n  // Body is null or undefined\n  if (body === null) {\n    return 0;\n  }\n\n  // Body is Blob\n  if (isBlob(body)) {\n    return body.size;\n  }\n\n  // Body is Buffer\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  }\n\n  // Detect form data input from form-data module\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  }\n\n  // Body is stream\n  return null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, _ref) => {\n  let {\n    body\n  } = _ref;\n  if (body === null) {\n    // Body is null\n    dest.end();\n  } else {\n    // Body is stream\n    await pipeline(body, dest);\n  }\n};","map":{"version":3,"names":["Stream","PassThrough","types","deprecate","promisify","Buffer","Blob","FormData","formDataToBlob","FetchError","FetchBaseError","isBlob","isURLSearchParameters","pipeline","INTERNALS","Symbol","Body","constructor","body","size","arguments","length","undefined","boundary","from","toString","isBuffer","isAnyArrayBuffer","ArrayBuffer","isView","buffer","byteOffset","byteLength","type","split","String","stream","Readable","disturbed","error","on","error_","url","message","bodyUsed","arrayBuffer","consumeBody","slice","formData","ct","headers","get","startsWith","parameters","URLSearchParams","text","name","value","append","toFormData","blob","buf","json","JSON","parse","TextDecoder","decode","prototype","Object","defineProperties","enumerable","data","TypeError","alloc","accum","accumBytes","chunk","destroy","push","readableEnded","_readableState","ended","every","c","join","concat","clone","instance","highWaterMark","p1","p2","Error","getBoundary","pipe","getNonSpecFormDataBoundary","extractContentType","request","getTotalBytes","getLengthSync","hasKnownLength","writeToStream","dest","_ref","end"],"sources":["/Users/ewang/Desktop/G36/codeclan_work/week_15/Capstone_Project_Reelax/reelax/node_modules/node-fetch/src/body.js"],"sourcesContent":["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from 'fetch-blob';\nimport {FormData, formDataToBlob} from 'formdata-polyfill/esm.min.js';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}