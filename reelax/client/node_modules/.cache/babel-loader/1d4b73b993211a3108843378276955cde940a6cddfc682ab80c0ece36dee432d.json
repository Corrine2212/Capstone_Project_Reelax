{"ast":null,"code":"import { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nlet s = 0;\nconst S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nlet f = 1;\nconst F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nconst lower = c => c | 0x20;\nconst noop = () => {};\nclass MultipartParser {\n  /**\n   * @param {string} boundary\n   */\n  constructor(boundary) {\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    const ui8a = new Uint8Array(boundary.length);\n    for (let i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  write(data) {\n    let i = 0;\n    const length_ = data.length;\n    let previousIndex = this.index;\n    let {\n      lookbehind,\n      boundary,\n      boundaryChars,\n      index,\n      state,\n      flags\n    } = this;\n    const boundaryLength = this.boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    const bufferLength = data.length;\n    let c;\n    let cl;\n    const mark = name => {\n      this[name + 'Mark'] = i;\n    };\n    const clear = name => {\n      delete this[name + 'Mark'];\n    };\n    const callback = (callbackSymbol, start, end, ui8a) => {\n      if (start === undefined || start !== end) {\n        this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n      }\n    };\n    const dataCallback = (name, clear) => {\n      const markSymbol = name + 'Mark';\n      if (!(markSymbol in this)) {\n        return;\n      }\n      if (clear) {\n        callback(name, this[markSymbol], i, data);\n        delete this[markSymbol];\n      } else {\n        callback(name, this[markSymbol], data.length, data);\n        this[markSymbol] = 0;\n      }\n    };\n    for (i = 0; i < length_; i++) {\n      c = data[i];\n      switch (state) {\n        case S.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= F.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n              state = S.END;\n              flags = 0;\n            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              callback('onPartBegin');\n              state = S.HEADER_FIELD_START;\n            } else {\n              return;\n            }\n            break;\n          }\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case S.HEADER_FIELD_START:\n          state = S.HEADER_FIELD;\n          mark('onHeaderField');\n          index = 0;\n        // falls through\n        case S.HEADER_FIELD:\n          if (c === CR) {\n            clear('onHeaderField');\n            state = S.HEADERS_ALMOST_DONE;\n            break;\n          }\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return;\n            }\n            dataCallback('onHeaderField', true);\n            state = S.HEADER_VALUE_START;\n            break;\n          }\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            return;\n          }\n          break;\n        case S.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n          mark('onHeaderValue');\n          state = S.HEADER_VALUE;\n        // falls through\n        case S.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('onHeaderValue', true);\n            callback('onHeaderEnd');\n            state = S.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case S.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n          state = S.HEADER_FIELD_START;\n          break;\n        case S.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n          callback('onHeadersEnd');\n          state = S.PART_DATA_START;\n          break;\n        case S.PART_DATA_START:\n          state = S.PART_DATA;\n          mark('onPartData');\n        // falls through\n        case S.PART_DATA:\n          previousIndex = index;\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < bufferLength && !(data[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = data[i];\n          }\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('onPartData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= F.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= F.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & F.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~F.PART_BOUNDARY;\n                callback('onPartEnd');\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & F.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                callback('onPartEnd');\n                state = S.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (previousIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n            callback('onPartData', 0, previousIndex, _lookbehind);\n            previousIndex = 0;\n            mark('onPartData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n          break;\n        case S.END:\n          break;\n        default:\n          throw new Error(`Unexpected state entered: ${state}`);\n      }\n    }\n    dataCallback('onHeaderField');\n    dataCallback('onHeaderValue');\n    dataCallback('onPartData');\n\n    // Update properties for the next call\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n  }\n  end() {\n    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n      this.onPartEnd();\n    } else if (this.state !== S.END) {\n      throw new Error('MultipartParser.end(): stream ended unexpectedly');\n    }\n  }\n}\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m) {\n    return;\n  }\n  const match = m[2] || m[3] || '';\n  let filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nexport async function toFormData(Body, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError('Failed to fetch');\n  }\n  const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n  if (!m) {\n    throw new TypeError('no or bad content-type header, no multipart boundary');\n  }\n  const parser = new MultipartParser(m[1] || m[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n  const onPartData = ui8a => {\n    entryValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  const appendToFile = ui8a => {\n    entryChunks.push(ui8a);\n  };\n  const appendFileToFormData = () => {\n    const file = new File(entryChunks, filename, {\n      type: contentType\n    });\n    formData.append(entryName, file);\n  };\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n  const decoder = new TextDecoder('utf-8');\n  decoder.decode();\n  parser.onPartBegin = function () {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = '';\n    headerValue = '';\n    entryValue = '';\n    entryName = '';\n    contentType = '';\n    filename = null;\n    entryChunks.length = 0;\n  };\n  parser.onHeaderField = function (ui8a) {\n    headerField += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  parser.onHeaderValue = function (ui8a) {\n    headerValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  parser.onHeaderEnd = function () {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n    if (headerField === 'content-disposition') {\n      // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n      const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n      if (m) {\n        entryName = m[2] || m[3] || '';\n      }\n      filename = _fileName(headerValue);\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === 'content-type') {\n      contentType = headerValue;\n    }\n    headerValue = '';\n    headerField = '';\n  };\n  for await (const chunk of Body) {\n    parser.write(chunk);\n  }\n  parser.end();\n  return formData;\n}","map":{"version":3,"names":["File","FormData","s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","constructor","boundary","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","write","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","Body","ct","test","TypeError","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","append","appendEntryToFormData","TextDecoder","toLowerCase","chunk"],"sources":["/Users/ewang/Desktop/G36/codeclan_work/week_15/Capstone_Project_Reelax/reelax/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}