{"ast":null,"code":"import { isIP } from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url) {\n  let originOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // 1. If url is null, return no referrer.\n  if (url == null) {\n    // eslint-disable-line no-eq-null, eqeqeq\n    return 'no-referrer';\n  }\n  url = new URL(url);\n\n  // 2. If url's scheme is a local scheme, then return no referrer.\n  if (/^(about|blob|data):$/.test(url.protocol)) {\n    return 'no-referrer';\n  }\n\n  // 3. Set url's username to the empty string.\n  url.username = '';\n\n  // 4. Set url's password to null.\n  // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n  url.password = '';\n\n  // 5. Set url's fragment to null.\n  // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n  url.hash = '';\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 6.1. Set url's path to null.\n    // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n    url.pathname = '';\n\n    // 6.2. Set url's query to null.\n    // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n    url.search = '';\n  }\n\n  // 7. Return url.\n  return url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set(['', 'no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url']);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n  if (!ReferrerPolicy.has(referrerPolicy)) {\n    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n  }\n  return referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  // Not applicable\n\n  // 2. Assert: origin is a tuple origin.\n  // Not for implementations\n\n  // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n  if (/^(http|ws)s:$/.test(url.protocol)) {\n    return true;\n  }\n\n  // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n  const hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n  const hostIPVersion = isIP(hostIp);\n  if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n    return true;\n  }\n  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n    return true;\n  }\n\n  // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n  // We are returning FALSE here because we cannot ensure conformance to\n  // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n  if (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n    return false;\n  }\n\n  // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n  if (url.protocol === 'file:') {\n    return true;\n  }\n\n  // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n  // Not supported\n\n  // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n  // Not supported\n\n  // 9. Return \"Not Trustworthy\".\n  return false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n  // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n  if (/^about:(blank|srcdoc)$/.test(url)) {\n    return true;\n  }\n\n  // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n  if (url.protocol === 'data:') {\n    return true;\n  }\n\n  // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n  // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n  // trustworthy.\n  if (/^(blob|filesystem):$/.test(url.protocol)) {\n    return true;\n  }\n\n  // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n  return isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request) {\n  let {\n    referrerURLCallback,\n    referrerOriginCallback\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n  // these cases:\n  // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n  // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n  // > algorithm.\n  if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n    return null;\n  }\n\n  // 1. Let policy be request's associated referrer policy.\n  const policy = request.referrerPolicy;\n\n  // 2. Let environment be request's client.\n  // not applicable to node.js\n\n  // 3. Switch on request's referrer:\n  if (request.referrer === 'about:client') {\n    return 'no-referrer';\n  }\n\n  // \"a URL\": Let referrerSource be request's referrer.\n  const referrerSource = request.referrer;\n\n  // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n  let referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n  //    origin-only flag set to true.\n  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n  // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n  //    referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  }\n\n  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n  //    policy considerations in the interests of minimizing data leakage. For example, the user\n  //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n  //    string, etc.\n  if (referrerURLCallback) {\n    referrerURL = referrerURLCallback(referrerURL);\n  }\n  if (referrerOriginCallback) {\n    referrerOrigin = referrerOriginCallback(referrerOrigin);\n  }\n\n  // 8.Execute the statements corresponding to the value of policy:\n  const currentURL = new URL(request.url);\n  switch (policy) {\n    case 'no-referrer':\n      return 'no-referrer';\n    case 'origin':\n      return referrerOrigin;\n    case 'unsafe-url':\n      return referrerURL;\n    case 'strict-origin':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      }\n\n      // 2. Return referrerOrigin.\n      return referrerOrigin.toString();\n    case 'strict-origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin;\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n\n      // 2. Return no referrer.\n      return 'no-referrer';\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      }\n\n      // Return referrerOrigin.\n      return referrerOrigin;\n    case 'no-referrer-when-downgrade':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      }\n\n      // 2. Return referrerURL.\n      return referrerURL;\n    default:\n      throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n  }\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n  //    and response’s header list.\n  const policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n  // 2. Let policy be the empty string.\n  let policy = '';\n\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n  //    string, then set policy to token.\n  // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n  // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n  for (const token of policyTokens) {\n    if (token && ReferrerPolicy.has(token)) {\n      policy = token;\n    }\n  }\n\n  // 4. Return policy.\n  return policy;\n}","map":{"version":3,"names":["isIP","stripURLForUseAsAReferrer","url","originOnly","arguments","length","undefined","URL","test","protocol","username","password","hash","pathname","search","ReferrerPolicy","Set","DEFAULT_REFERRER_POLICY","validateReferrerPolicy","referrerPolicy","has","TypeError","isOriginPotentiallyTrustworthy","hostIp","host","replace","hostIPVersion","endsWith","isUrlPotentiallyTrustworthy","determineRequestsReferrer","request","referrerURLCallback","referrerOriginCallback","referrer","policy","referrerSource","referrerURL","referrerOrigin","toString","currentURL","origin","parseReferrerPolicyFromHeader","headers","policyTokens","get","split","token"],"sources":["/Users/ewang/Desktop/G36/codeclan_work/week_15/Capstone_Project_Reelax/reelax/node_modules/node-fetch/src/utils/referrer.js"],"sourcesContent":["import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response’s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}